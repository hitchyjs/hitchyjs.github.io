<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link href="https://fonts.googleapis.com/css?family=Archivo+Black|Dosis" rel="stylesheet">
	<link href="https://code.cdn.mozilla.net/fonts/fira.css" rel="stylesheet">
	<link href="/assets/style.css" rel="stylesheet">
	<title>hitchyjs</title>
</head>
<body>
<div id="wrapper">
	<header>
		<div class="inner">
			<h1><a href="/pages/">HitchyJS</a></h1>
		</div>
		<div class="nav">
			<nav>
				<a href="index.html">home</a> <a href="bootstrap.html">bootstrap</a>
			</nav>
		</div>
	</header>
	<article>
		<h2 id="bootstrap">Bootstrap</h2>
<h3 id="introduction">Introduction</h3>
<p>Bootstrap is the way is detecting and collecting all required information to properly handle incoming requests later. This process runs on starting up hitchy-based application and must be completed without any error.</p>
<h4 id="hitchy-s-common-module-pattern">Hitchy&#39;s Common Module Pattern</h4>
<p>Hitchy repeatedly supports particular pattern for providing additional data and/or functionality. This pattern is available for injecting components into your hitchy setup, for providing custom configuration in your project&#39;s configuration related to hitchy and in all models, controllers, policies and services of your project and its extending components.</p>
<p>In either case any such <em>module</em> might provide requested data as such. However, the more beneficial way is to export a single function that is expected to return that requested data. You are advised to stick with the latter technique to gain full access on API and options used to start/inject hitchy. By exporting function component you might even return promise to provide requested data with delay. For example, discovery process or compilation of project&#39;s configuration is delayed until some returned promise is resolved with eventually provided information.</p>
<p>A short example of hitchy&#39;s common module pattern looks like this:</p>
<pre><code class="lang-javascript">/**
 * Provides implementation for second stage of bootstrapping hitchy instance.
 *
 * @this HitchyAPI
 * @param {HitchyOptions} options
 * @returns {function(modules:HitchyComponentHandle[]):Promise.&lt;HitchyComponentHandle[]&gt;}
 */
module.exports = function( options ) {
    let api = this;

    return {
        // here comes your actual data 
        configure: function() {

        }
    };
};
</code></pre>
<p>By following this pattern access on hitchy&#39;s API is provided through closure variable <code>api</code> here. This includes all found configuration, any model or controller etc. Thus, when documentation to refers some variable or data available as <code>api.foo.bar</code> this is referring to the access granted here. In addition <code>options</code> is available to access configuration provided by application or runtime environment injecting hitchy. E.g. on using hitchy&#39;s internal server this includes any custom command line option.</p>
<h3 id="triangulation">Triangulation</h3>
<p>First of all hitchy is trying to detect its runtime environment detecting all basically required information such as current project&#39;s folder etc. This is primarily achieved by inspecting the options provided on injecting hitchy into your application. If those options don&#39;t select any project folder the triangulation is starting to search for obvious project folders to depend on hitchy starting in current working directory or in folder containing file used to start current nodejs runtime (the main file). If this doesn&#39;t lead to detection of obvious root folder the project containing current hitchy working copy in its <code>node_modules</code> hierarchy is searched.</p>
<p>As a result of triangulation hitchy knows two folders:</p>
<ul>
<li><code>&lt;hitchyFolder&gt;</code> is the folder containing hitchyjs framework installation. This information is available as <code>options.hitchyFolder</code> on complying with common modules pattern.</li>
<li><code>&lt;projectFolder&gt;</code> is the folder containing custom implementation relying on hitchyjs as well as a custom set of extending components (a.k.a. extensions). On using common modules pattern this pathname is available via <code>options.projectFolder</code>.</li>
</ul>
<h3 id="discovery">Discovery</h3>
<p>After triangulation hitchy is trying to discover all compatible components in <code>&lt;projectFolder&gt;</code> and components distributed with hitchy framework itself as its core components in <code>&lt;hitchyFolder&gt;</code>. The former are expected as installed npm packages under <code>&lt;projectFolder&gt;/node_modules</code>. The latter are read from <code>&lt;hitchyFolder&gt;/core</code>.</p>
<p>Any component is considered compatible with hitchyjs on providing special file <code>hitchy.json</code> in its root folder. This file is providing optional information on component. It might be empty by default (though, as a valid JSON file it should contain some empty object at least). It is always required as such so hitchy is considering containing package compatible.</p>
<p>Every discovered valid component is loaded then. Either component is expected to provide a set of functions and meta information to be obeyed in one of several bootstrap stages performed sequentially afterwards. Every component might rely on common module pattern here.</p>
<h4 id="steps-of-discovery">Steps of Discovery</h4>
<ol>
<li><strong>Discover:</strong> Folders mentioned before are shallowly searched for sub folders containing <code>hitchy.json</code> file. Any found <code>hitchy.json</code> file is read and a handle describing the component and its meta data (which is the content of <code>hitchy.json</code> file) is appended to a collection of handles of basically discovered components.<blockquote>
<p><strong>Always consider such handles as read-only information!</strong></p>
<p>For the sake of performance and reduced memory footprint handles might be shared between requests during bootstrap so changing handles might be possible. But this isn&#39;t guaranteed behaviour. Don&#39;t use it for session data or controlling discovery e.g. by adjusting foreign component&#39;s handle etc. </p>
</blockquote>
</li>
<li>All handles are compiled in a map to look up handles by component&#39;s name.</li>
<li><strong>Load:</strong> Collection of handles is used to load every component and to request its API. This happens sequentially, but in unspecified order.<ul>
<li>This request is providing map compiled before basically for detecting what components are available. By using <em>common modules pattern</em> any component may implement decisive code providing API functions and some meta data overlay to replace parts of its meta data read from <code>hitchy.json</code> file before. <em>When loading component it mustn&#39;t rely on these handles providing any listed component&#39;s API.</em></li>
<li>The declaration of a component&#39;s role is processed immediately after gathering its API.</li>
<li>Any component may export its API as such or stick with common modules pattern. In the latter case exporting function of module is invoked with two additional arguments:<ol>
<li><code>options</code> is provided as first argument in compliance with common modules pattern.</li>
<li><code>mapOfComponents</code> is referring to the map of components&#39; names into either component&#39;s handle.</li>
<li><code>handle</code> is referring to (read-only) handle of component itself e.g. for accessing meta data read from <code>hitchy.json</code> file via <code>handle.meta</code>.</li>
</ol>
</li>
</ul>
</li>
<li>After having requested all discovered components&#39; APIs all components still filling some role are notified. This notification is enabling either component to gather and save access on APIs of components it is replacing prior to dropping the latter.</li>
<li><strong>Sort:</strong> Every component is expected to list roles of components it depends on. This information is used to deduce a certain order of processing components further on ensuring that any component is processed after those components it depends on.</li>
<li><strong>Publish:</strong> Eventually, APIs of all components still filling a role are promoted in <code>api.components</code> using role of component as key, so that component <code>hitchy-foo</code> declaring to fill role <code>bar</code> is available under <code>api.components.bar</code>.</li>
</ol>
<h4 id="name-vs-role">Name vs. Role</h4>
<p>Every component is having a <strong>name</strong> matching basename of folder containing the component. So, if there is an component in <code>&lt;projectFolder&gt;/node_modules/hitchy-foo</code> the component&#39;s name is <code>hitchy-foo</code>. Names are used to identify components. The name must be unique in a single applicaton relying on hitchy. It should be even globally unique. During discovery any component gets informed on what other components are about to be loaded. The name is designed to provide opportunity to safely detect availability of a certain component to rely on.</p>
<p>Every component may declare some <strong>role</strong> it is filling, too. By default a component&#39;s role is equivalent to its name. Any component may declare different role in its <code>hitchy.json</code> file. Such a declaration is called <em>static declaration</em> of role. On loading component to gather its API this API might include meta information to replace related information read from <code>hitchy.json</code> file before. This includes declaration of role. Re-declaring role this way is called <em>dynamic declaration</em> of role.</p>
<p>Roles are used on processing dependencies between hitchy components resulting in a certain order of processing components in every stage of bootstrapping hitchy.</p>
<blockquote>
<p>In fact, all succeeding stages rely on order detected in discovery stage. All but shutdown stage process include components in this same way. Shutdown stage is using reverse order to shut down components.</p>
</blockquote>
<p>Any dynamic declaration of a role supersedes its static declaration. In addition it replaces static declaration of same role in any other component discovered before. Eventually any role mustn&#39;t be filled by more than one component in a single hitchy-based application. Thus bootstrapping fails if two components <em>dynamically</em> declare to fill the same role. </p>
<h4 id="overriding">Overriding</h4>
<p>hitchy features <em>component overloading</em> by design. Most of this is prepared in discovery stage.</p>
<ul>
<li>By dynamically declaring commonly used role any component might replace default component used otherwise.</li>
<li>Every component gets information about all other discovered components. Thus either component is enabled to dynamically declare a role depending what other components are available.</li>
<li>At end of discovery all components with roles replaced by other components get dropped, but prior to that every component with API function <code>onDiscovered()</code> is provided with APIs of all components basically discovered before to gather access on API of components it is replacing.</li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>In configuration stage all configuration provided in project is loaded and merged. The result configuration is an object with every immediate property containing to content provided in one of several files located in subfolder <code>config</code> of current project. Every file is expected to provide some data to become value of related property.</p>
<p>This configuration is commonly available in <code>api.runtime.config</code>.</p>
<p>After all custom configuration has been compiled all discovered components are invoked to process this compiled configuration e.g. by adjusting, validating, normalizing, converting, replacing any contained information.</p>
<p>Every component may export function <code>configure()</code> to be invoked during this stage of bootstrap. This method is invoked with </p>
<ul>
<li><code>this</code> referring to <code>api</code>, </li>
<li><code>options</code> in first parameter (similar to common module pattern) and </li>
<li>information on component including its meta data read from its <code>hitchy.json</code> file before in second parameter. </li>
</ul>
<blockquote>
<p>Providing <code>api</code> and <code>options</code> here is a bit redundant, but makes component coding slightly more flexible. Finally it doesn&#39;t hurt either.</p>
</blockquote>
<p>The method <code>configure()</code> might return promise to delay further configuration in particular and bootstrap in general.</p>
<pre><code class="lang-javascript">module.exports = function( options ) {
    let api = this;

    return {
        configure: function( options, componentHandle ) {
            // TODO put your configuration processing here
        }
    };
};
</code></pre>
<blockquote>
<p>At end of bootstrap the API will be sealed deeply to prevent accidental modifications of this configuration during actual runtime of your hitchy-based application. Thus you should do all required qualifcation of configuration data here.</p>
</blockquote>
<p>When all configuration has been qualified bootstrap process is loading all models, controllers, policies and services provided by component, again obeying order resulting from discovery before as well as supporting hitchy&#39;s common module pattern. </p>
<p>So, if you have components <code>foo</code> and <code>bar</code> with <code>foo</code> listing <code>bar</code> as its dependency then</p>
<ul>
<li>all models of <code>bar</code> are loaded in unspecified order,</li>
<li>all controlllers of <code>bar</code>are loaded in unspecified order,</li>
<li>all policies of <code>bar</code> are loaded in unspecified order,</li>
<li>all services of <code>bar</code> are loaded in unspecified order,</li>
<li>all models of <code>foo</code> are loaded in unspecified order,</li>
<li>all controlllers of <code>foo</code>are loaded in unspecified order,</li>
<li>all policies of <code>foo</code> are loaded in unspecified order and</li>
<li>all services of <code>foo</code> are loaded in unspecified order.</li>
</ul>
<p>Those models, controllers, policies and services are located in folder <code>api/models</code>, <code>api/controllers</code>, <code>api/policies</code> and <code>api/services</code> of either component. Any model, controller, service or policy might use function according to <em>common module pattern</em>. In that case any previous state of a model, controller, etc. with the same name (e.g. as provided by another component before) is provided in second parameter so the function may extend that one&#39;s functionality.</p>
<p>Results are cumulated and finally available in <code>api.runtime.models</code>, <code>api.runtime.controllers</code>, <code>api.runtime.policies</code> and <code>api.runtime.services</code>. Either element&#39;s name is derived from basename of related file without adjusting case or similar except for stripping off extension <code>.js</code>.</p>
<h3 id="initialization">Initialization</h3>
<p>After configuration stage all component are initialized. This stage is primary useful to process all configuration and handle described models etc. e.g. for preparing data storage backend to match schema described by models.</p>
<p>Just like in configuration stage every component may export function <code>initialize()</code> to be invoked during this stage of bootstrap. This method is invoked with the same arguments described on configuration stage before. It also might return promise to delay further initialization in particular and bootstrap in general.</p>
<pre><code class="lang-javascript">module.exports = function( options ) {
    let api = this;

    return {
        initialize: function( options, componentHandle ) {
            // TODO put your component&#39;s initialization code here
        }
    };
};
</code></pre>
<h3 id="routing">Routing</h3>
<p>When initialization is done the routing is established. Therefore every component may provide sets of routing definitions to precede or succeed custom routings of current project (as given in configuration <code>api.runtime.config.routing</code>) and automatic blueprint routing e.g. derived from controllers provided before.</p>
<p>hitchy manages two separate sets of routes: one for policies and one for controllers. Therefore any module may provide separate sets of routes by epxorting <code>policies</code> for policy-related routing provision and <code>routing</code> for controller-related routing provision. Either information is expected to be object containing one or two properties called <code>before</code> and <code>after</code> with each providing map of routing patterns into routing target descriptions. All routings provided in <code>before</code> are preceding routes found in project configuration and blueprint routes. All routings provided in <code>after</code> are processed after those routes. </p>
<blockquote>
<p>Later requests are passing <em>all</em> matching routes related to policies prior to find the first matching route related to some controller to finally handle the request.</p>
</blockquote>
<p>Every single route is defined as a route pattern mapping onto description of a routing target. </p>
<p>The route pattern is a URL pattern optionally prepended by name of some HTTP method this particular route is valid for. If method name is omitted the route is processed on any HTTP request method.</p>
<p>The routing target is either</p>
<ul>
<li>a string containing names of a controller and one of its static methods separated by single period or</li>
<li>an object providing name of controller and its static method in separate properties <code>controller</code> and <code>method</code> or</li>
<li>a function to be directly associated with processing the request.</li>
</ul>
<p>In policy-related either routing target is invoked with three parameters <code>req</code>, <code>res</code> and <code>next</code> in accordance with usual pattern introduced by expressjs and its predecessors. In controller related routing the third parameter is omitted as the routing target is expected to respond to solely the request.</p>
<p>In either routing the invoked routing target is invoked with <code>this</code> referring to the current request context which is providing additional information:</p>
<ul>
<li><code>this.api</code> is referring to hitchy&#39;s API. This is the same provided on following common module pattern described above.</li>
<li><code>this.request</code> is referring to same object as first provided argument.</li>
<li><code>this.response</code> is referring to same object as second provided argument.</li>
<li><code>this.data</code> is an initially empty object available to store arbitrary data associated with current request e.g. to collect session data in early policy-related routing processors so its availale in later routing processors.</li>
</ul>
<p>Any routing target might return promise to delay further processing. <strong>In policy-related routing returning promises is available if method isn&#39;t taking third parameter mentioned above (<code>next</code>).</strong></p>
<h2 id="meta-data">Meta Data</h2>
<p>All meta data of a hitchy component is provided in file <code>hitchy.json</code> found in root folder of component. The file contains JSON-encoded object with a selection of all optional properties:</p>
<h3 id="role">role</h3>
<p>This property takes string providing the current component&#39;s internal name. This is derived from basename of its containing folder. By explicitly providing role here component might declare to fill certain role. This is useful to promote the component for replacing another one.</p>
<h3 id="dependencies">dependencies</h3>
<p>This optional list of strings lists all roles of hitchy components this current component depends on. This list is used to ensure all required components are available. In addition it affects the order of bootstrapping components.</p>

	</article>
	<footer>
		<div class="inner">
			<label>&copy; 2017</label> <a href="http://cepharum.de/">cepharum GmbH</a>
			<a href="license.html">License</a>
		</div>
	</footer>
</div>
</body>
</html>