<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link href="https://fonts.googleapis.com/css?family=Archivo+Black|Dosis" rel="stylesheet">
	<link href="https://code.cdn.mozilla.net/fonts/fira.css" rel="stylesheet">
	<link href="/assets/style.css" rel="stylesheet">
	<title>hitchyjs</title>
</head>
<body>
<div id="wrapper">
	<header>
		<div class="inner">
			<h1><a href="/pages/">HitchyJS</a></h1>
		</div>
		<div class="nav">
			<nav>
				<a href="index.html">home</a> <a href="bootstrap.html">bootstrap</a> <a href="concepts.html">concepts</a> <a href="extensions.html">extensions</a>
			</nav>
		</div>
	</header>
	<article>
		<h1 id="understanding-extensions">Understanding Extensions</h1>
<p>Hitchy by itself isn&#39;t capable of doing quite much. It strongly relies on extensions. This document provides brief summary on how extensions are integrated into hitchy and describes how to write extensions for hitchy.</p>
<h2 id="finding-and-loading-extensions">Finding and Loading Extensions</h2>
<p>All extensions get loaded on hitchy&#39;s bootstrap. Thus all extensions are loaded prior to handling first request. Any folder in your project&#39;s <strong>node_modules</strong> is tested for containing <strong>hitchy.json</strong> file and considered hitchy extension then. This file must be located in root folder of extension and contains the extension&#39;s <em>static meta information</em>.</p>
<p>Hitchy is loading any extension by &quot;requiring&quot; its folder. Thus you must provide a main script named <strong>index.js</strong> in root folder of your extension or name any other main script in your extension&#39;s <strong>package.json</strong> file.</p>
<blockquote>
<p>Every extension must provide main script file to be loaded. This main script may be empty by means of absolutely blank text file.</p>
</blockquote>
<p>Here comes a brief profile of <em>extension loading</em>:</p>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> discovery</li>
<li><strong>purpose:</strong> (or <em>what is it good for in an extension</em>)<ul>
<li>detect available extensions</li>
<li>choose role to fill eventually</li>
<li>provide <em>dynamic meta information</em> (see section on $meta below)</li>
<li><em>provide API of extension</em></li>
</ul>
</li>
<li><strong>knowledge:</strong> (or <em>what info is available to the extension</em>)<ul>
<li>hitchy&#39;s core API</li>
<li>runtime options</li>
<li>names of all basically available extensions</li>
<li>static meta information (as defined in extension&#39;s <strong>hitchy.json</strong> file)</li>
</ul>
</li>
<li><strong>processing order:</strong> arbitrary</li>
<li><strong>supported types:</strong><ul>
<li>object</li>
<li>common module pattern</li>
</ul>
</li>
</ul>
<h2 id="an-extension-s-basic-api">An Extension&#39;s Basic API</h2>
<p>Every extension is considered to expose information through several properties usually complying with common module function pattern. </p>
<blockquote>
<p>Any extension may omit some or even all of the properties listed here. This results in certain default behaviour.</p>
</blockquote>
<p>Here comes a list of API properties obeyed by hitchy bootstrap process.</p>
<h3 id="-meta-"><code>$meta</code></h3>
<p>This property is processed on loading extension. It is merged with meta information read from <strong>hitchy.json</strong> file before.</p>
<blockquote>
<p>$meta is always an object. It can&#39;t be function complying with common module function pattern. This doesn&#39;t hurt as the API itself may be provided by function on extension complying with common module pattern.</p>
</blockquote>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> discovery</li>
<li><strong>purpose:</strong><ul>
<li>adjust meta information depending on current context, e.g.<ul>
<li>select role to fill</li>
<li>select actual dependencies of extension</li>
</ul>
</li>
</ul>
</li>
<li><strong>supported types:</strong> <ul>
<li>object</li>
</ul>
</li>
</ul>
<h4 id="on-roles">On Roles</h4>
<p>Extensions are required to fill a certain role, which is simply a name given as string. Roles are important for managing dependencies between extensions. By resolving dependencies hitchy is establishing certain order applied to all further processing involving extensions.</p>
<p>There are three kinds of roles:</p>
<ol>
<li>Every extension is assigned implicit role on missing any explicit declaration. This implicit role is equivalent to the extension&#39;s name which in turn is just the basename of folder containing it.</li>
<li>In <strong>hitchy.json</strong> file role of extension may be declared explicitly as property <strong>role</strong>. </li>
<li>The extension may provide dynamic meta information including property <strong>role</strong> as well.</li>
</ol>
<p>While the two former are called <em>static role</em> of extension, the latter is called its <em>dynamic role</em>. On processing roles of extensions dynamic role takes precedence over static ones, explicitly declared one over implicit one.</p>
<h5 id="what-if-two-extensions-declare-the-same-role-">What if Two Extensions Declare the Same Role?</h5>
<p><em>In scope of an application every role may be filled by single extension, only.</em> </p>
<p>However, multiple extensions may statically declare to fill the same role as long as one of them is declaring that role dynamically, too. Dynamic role of one extension might clash with static roles of other extensions actually revoking static roles of those. Extensions without any role won&#39;t be processed any further. </p>
<p>Finally two extensions must not claim to fill the same role dynamically.</p>
<h5 id="what-if-role-is-revoked-from-extension-">What if Role is Revoked from Extension?</h5>
<p>Whenever dynamic role of one extension causes revocation of same role statically declared by another one the latter extension doesn&#39;t fill any role anymore unless it declares one dynamically. </p>
<blockquote>
<p>Due to arbitrary processing of extensions in this stage trying to declare role dynamically after having lost static role may be considered bad practice.</p>
</blockquote>
<p>Extensions without role won&#39;t be processed after <strong>onDiscovered</strong> (see below). Hitchy won&#39;t obey them on configuring or initializing extensions and on preparing routes. It won&#39;t be exposed as part of Hitchy&#39;s runtime API. However, any replacing extension might use it for extending its functionality.</p>
<h5 id="what-is-it-good-for-">What is it Good for?</h5>
<p>Roles are used to find extensions on resolving dependencies of either extension. Dynamic roles are useful to check current application&#39;s scenario first by inspecting list of available extensions. By declaring role dynamically one extension can replace another one transparently e.g. for extending the latter one&#39;s functionality.</p>
<h4 id="on-dependencies">On Dependencies</h4>
<p>Extensions may list roles of other extensions they rely on. Hitchy is using this definition of dependencies to apply certain order for processing extensions further on. Any extension gets processed after all its dependencies.</p>
<p>Any application relying on hitchy may choose roles filled by extensions as its initial dependencies. This way hitchy does not load all extensions filling a role but those actually required as immediate as well as mediate dependencies of application.</p>
<h3 id="-ondiscovered-"><code>onDiscovered()</code></h3>
<p>An extension may expose function to be called after having finished discovery of extensions.</p>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> discovery</li>
<li><strong>purpose:</strong> <ul>
<li>save access on replaced extensions e.g. for extending their functionality</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s core API</li>
<li>runtime options</li>
<li>roles filled by extensions eventually</li>
<li>references on APIs of all previously discovered extensions (including those having lost their role)</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h3 id="-configure-"><code>configure()</code></h3>
<p>After discovery of extensions hitchy is reading and merging all configuration files included with application. After this hitchy is notifying all extensions for optional validation and normalization of configuration data.</p>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> configuration</li>
<li><strong>purpose:</strong> <ul>
<li>validate and/or normalize application configuration</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s core API plus<ul>
<li>compiled configuration in <code>api.runtime.config</code></li>
</ul>
</li>
<li>runtime options</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h3 id="-onexposing-"><code>onExposing()</code></h3>
<p>Next hitchy is collecting and compiling elements of extension API. Those elements are divided into models, controllers, policies and services. Extensions don&#39;t have to provide such elements at all. If multiple extensions use same name for some kind of element versions are merged successively.</p>
<ul>
<li>An extension&#39;s models reside in folder <code>api/models</code>.</li>
<li>An extension&#39;s controllers reside in folder <code>api/controllers</code>.</li>
<li>An extension&#39;s policies reside in folder <code>api/policies</code>.</li>
<li>An extension&#39;s services reside in folder <code>api/services</code>.</li>
</ul>
<blockquote>
<p>On defining any such element hitchy does not qualify models or inject routes to controllers automatically. Instead an application might require extension taking care of that.</p>
</blockquote>
<p>After having collected and compiled API elements of all extensions either extension is notified via API function <strong>onExposing()</strong>.</p>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> exposure</li>
<li><strong>purpose:</strong> <ul>
<li>qualify definitions of models, controllers, policies and services (e.g. by extension introducing basic support for models or similar)</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s full API incl. core, configuration and recently compiled elements in <code>api.runtime.models</code>, <code>api.runtime.controllers</code>, etc.</li>
<li>runtime options</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h3 id="-initialize-"><code>initialize()</code></h3>
<p>Every module may provide custom initialization handler e.g. to finally connect to some data source or sync model definitions with schema of data source.</p>
<blockquote>
<p>As a counterpart to this <code>shutdown()</code> may be used to release resources requested here.</p>
</blockquote>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> initialization</li>
<li><strong>purpose:</strong> <ul>
<li>initialize instance of extension in context of current application runtime (e.g. link to database, etc.)</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s full API incl. core, configuration and elements</li>
<li>runtime options</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h3 id="-routes-and-policies-"><code>routes</code> and <code>policies</code></h3>
<p>After initializing extension and gaining access on backends to be available through some extension it is time to declare routes mapping incoming requests onto controllers for generating proper responses.</p>
<p>Every extension may provide one or two separate maps for matching incoming requests and select method in controller or policy to process the request. First map is for policy routing and is given in API property <code>policies</code>. The second one is regarding responder routing and is given in API property <code>routes</code>.</p>
<blockquote>
<p>Either map may be given literally (thus being defined on loading extension) or as a function complying with common module function pattern to generate map now. The latter case enables definition of routes depending on application&#39;s actual context.</p>
</blockquote>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> router configuration</li>
<li><strong>purpose:</strong> <ul>
<li>(compile and) provide map of request URL patterns into selection of methods to invoke for filtering requests (<em>policies</em>) or for responding (<em>responders</em>)</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s full API incl. core, configuration and elements</li>
<li>runtime options</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>object</li>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h4 id="important-note-on-routing">Important Note on Routing</h4>
<p>Request dispatching doesn&#39;t obey order of routes given by single extension. Thus any extension shouldn&#39;t rely on routes being processed the same way they are listed in source code, but carefully choose request URL patterns for uniquely matching. On one hand that&#39;s due to improving organization of routes for fast processing. That&#39;s way routing maps are organized as objects in javascript. On the other hand properties of objects can&#39;t be enumerated in a reliable order. That&#39;s due to specification for implementations of javascript engine.</p>
<p>Routes of different extensions are processed in dependency-based order of extensions.</p>
<h3 id="-shutdown-"><code>shutdown()</code></h3>
<p>This method is expected to implement counterpart to <code>initialize()</code> described before.</p>
<p>On properly shutting down hitchy application it first closes all open client connections. After that it shuts down application by notifying all extensions in reverse dependency-based order using this optionally provided API method. Due to reversing order of extension processing any extension that was initialized last on bootstrap gets shut down first now.</p>
<h4 id="profile">Profile</h4>
<ul>
<li><strong>stage:</strong> application shutdown</li>
<li><strong>purpose:</strong> <ul>
<li>release resources requested on initializing extension</li>
</ul>
</li>
<li><strong>knowledge:</strong><ul>
<li>hitchy&#39;s full API incl. core, configuration and elements</li>
<li>runtime options</li>
<li>collected information on current extension (incl. its folder, name, meta information and API)</li>
</ul>
</li>
<li><strong>processing order:</strong> reverse dependency-based</li>
<li><strong>supported types:</strong> <ul>
<li>common module function pattern</li>
</ul>
</li>
</ul>
<h2 id="profile-summary">Profile Summary</h2>
<table>
<thead>
<tr>
<th>property</th>
<th>stage</th>
<th>knowledge</th>
<th>dependency-based order</th>
<th>supported types</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>loading</em></td>
<td>discovery</td>
<td>Core, Options</td>
<td>no</td>
<td>object or CMP</td>
</tr>
<tr>
<td><code>$meta</code></td>
<td>discovery</td>
<td>-</td>
<td>no</td>
<td>object</td>
</tr>
<tr>
<td><code>onDiscovered()</code></td>
<td>discovery</td>
<td>Core, Options</td>
<td>yes</td>
<td>CMFP</td>
</tr>
<tr>
<td><code>configure()</code></td>
<td>configuration</td>
<td>Core + Config, Options</td>
<td>yes</td>
<td>CMFP</td>
</tr>
<tr>
<td><code>onExposing()</code></td>
<td>exposure</td>
<td>Full API, Options</td>
<td>yes</td>
<td>CMFP</td>
</tr>
<tr>
<td><code>initialize()</code></td>
<td>initialization</td>
<td>Full API, Options</td>
<td>yes</td>
<td>CMFP</td>
</tr>
<tr>
<td><code>policies()</code></td>
<td>router setup</td>
<td>Full API, Options</td>
<td>yes</td>
<td>object or CMFP</td>
</tr>
<tr>
<td><code>routes()</code></td>
<td>router setup</td>
<td>Full API, Options</td>
<td>yes</td>
<td>object or CMFP</td>
</tr>
<tr>
<td><code>shutdown()</code></td>
<td>shutdown</td>
<td>Full API, Options</td>
<td>yes, reversed</td>
<td>CMFP</td>
</tr>
</tbody>
</table>

	</article>
	<footer>
		<div class="inner">
			<label>&copy; 2017</label> <a href="http://cepharum.de/">cepharum GmbH</a>
			<a href="license.html">License</a>
		</div>
	</footer>
</div>
</body>
</html>