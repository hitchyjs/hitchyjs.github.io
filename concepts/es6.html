<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><base href="/"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="design/index.css"><title>ECMAScript 6 | Hitchy</title></head><body class="page"><div id="wrapper"><div id="north"><div class="navigation"><nav class="primary center-block"><ul><li class="item"><a href="">Home</a></li><li class="item"><a href="about/">About</a></li><li class="item"><a href="download/">Download</a></li><li class="selected item"><a href="concepts/">Concepts</a></li><li class="item"><a href="runtime/">At Runtime</a></li><li class="item"><a href="extensions/">Extensions</a></li></ul><div class="boilerplate"><div class="site-title">Hitchy</div><div class="site-subtitle">a Javascript-based web application framework</div></div></nav></div><div class="center-block"><h1>ECMAScript 6</h1></div></div><div id="main"><div class="columnizer"><div id="core"><article class="center-block"><h2 id="Modern-Tools-Come-With-Modern-Language"><a href="#Modern-Tools-Come-With-Modern-Language" class="headerlink" title="Modern Tools Come With Modern Language"></a>Modern Tools Come With Modern Language</h2><p><a href="http://es6-features.org/" target="_blank" rel="external">ES6</a> is the next generation of Javascript language and it is mostly <a href="http://node.green" target="_blank" rel="external">supported in current LTS releases of NodeJS</a>. Hitchy was designed to run server-side using NodeJS and there is no intention or even some kind of sense in running hitchy in the ambiguous world of browsers. Therefore it is time to start using ES6 and all its benefits! </p>
<p>As a concept or paradigm of Hitchy this doesn’t <em>require</em> anyone to replace existing skills in coding with Javascript by all the neat features that come with ES6. But it doesn’t demand to keep code downward compatible with any older engine either. In addition there is no need to use transpilers or similar to convert modern Javascript into plain old Javascript. And since ES6 comes with class inheritance, destructuring, default parameters, promises, generators, iterators etc. there is no need to compile code written in some fancy Javascript-like language into Javascript to be run with NodeJS.</p>
<h3 id="Quest-For-The-Best-Mix"><a href="#Quest-For-The-Best-Mix" class="headerlink" title="Quest For The Best Mix"></a>Quest For The Best Mix</h3><p>When using new features of Javascript it is always worth taking into account their impact on performance. For example, Javascript greatly suffers from deeply nesting code into functions called recursively. Same applies to utilizing iterators invoking same callback for every item found on iterating larger arrays, lists or similar. Sometimes sticking with good old for-loop is far better than reducing code to one-liners without knowing what is happening under the hood.</p>
<h4 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h4><p>Let’s consider this easy-to-read code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = someArray</div><div class="line">	.filter( <span class="function"><span class="params">i</span> =&gt;</span> i )</div><div class="line">	.map( <span class="function"><span class="params">value</span> =&gt;</span> processorFn( value ) )</div><div class="line">	.slice( <span class="number">0</span>, <span class="number">10</span> );</div></pre></td></tr></table></figure>
<p>It’s easy to see what’s going on there. But how fast is it in case of <code>someArray</code> containing 1000, 10.000 or even 100.000 elements? And how does it compare to the following code doing the very same thing?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> length = someArray.length;</div><div class="line"><span class="keyword">let</span> limit  = <span class="built_in">Math</span>.min( <span class="number">10</span>, length );</div><div class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>( limit );</div><div class="line"><span class="keyword">let</span> write  = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> read = <span class="number">0</span>; read &lt; length &amp;&amp; write &lt; limit; read++ ) &#123;</div><div class="line">	<span class="keyword">let</span> value = someArray[read];</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ( value ) &#123;</div><div class="line">		result[write++] = processorFn( value );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">result.splice( write, limit - write );</div></pre></td></tr></table></figure>
<p>Both implementations achieve the same result. But the latter does it very fast. And yes, the latter code suffers from readability thus resulting in hardened maintenance of code. But that’s what (proper) unit tests are meant to support.</p>
<blockquote>
<h3 id="Anecdote"><a href="#Anecdote" class="headerlink" title="Anecdote"></a>Anecdote</h3><p>We’ve seen Javascript code finding about 500.000 (half a million) occurrences of a small string of up to 3 bytes in a 140 MByte haystack string and mapping that set of occurrences into unique set of text line indexes containing those occurrences within less than 500ms on a higher-value 2015 embedded system just because of sticking with performance as described before. </p>
<p>Using iterators and callbacks same search took several minutes to complete.</p>
</blockquote>
<p>In the end the optimum should depend on the actual impact on performance: code running just a few times on boot might use iterators whereas code involved in processing every request to process lists should stick with a more complex, faster approach.</p>
<p>Speaking of callbacks and performance this brings us to <a href="concepts/dependencies.html">another concept of Hitchy</a>.</p>
</article></div><div id="left"><nav class="sub navigation"><ul><li class="item"><a href="concepts/core.html">Core Principles</a></li><li class="item selected"><a href="concepts/es6.html">ECMAScript 6</a></li><li class="item"><a href="concepts/dependencies.html">On Dependencies</a></li><li class="item"><a href="concepts/promises.html">Promises</a></li><li class="item"><a href="concepts/common_patterns.html">Common Patterns</a></li><li class="item"><a href="concepts/the_meta_file.html">The Meta File</a></li></ul></nav></div><div id="right"></div></div></div><div id="south"><div class="center-block"><div class="copyright">&copy; 2018 <a href="http://cepharum.de" target="_blank">cepharum GmbH</a></div> - <nav class="footer"><ul><li class="item"><a href="imprint/">Imprint</a></li></ul></nav> - <div class="timestamp">Last Update: April 26, 2017 1:16 AM</div></div></div></div><script type="text/javascript" src="js/fx.js"></script></body></html>